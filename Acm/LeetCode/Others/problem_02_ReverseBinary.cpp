#include <iostream>
#include <stdint.h>
using namespace std;

/* 190 颠倒二进制位
    颠倒给定的32位无符号整数的二进制位示例 1：

输入: 00000010100101000001111010011100
输出: 00111001011110000010100101000000
解释: 输入的二进制串 00000010100101000001111010011100
表示无符号整数 43261596， 因此返回 964176192，
其二进制表示形式为 00111001011110000010100101000000。

模拟： 直接模拟，对新数进行左移，对每一位取&，拿出当前数，加到新数中，旧数右移。

*/

class Solution{
public:
    //直接模拟
    uint32_t reverseBin(uint32_t n){
        uint32_t ans = 0;
        for (int i = 0; i < 32; i++)
        {
            ans<<= 1;
            ans+=n & 1;
            n>>= 1;
        }
        return ans;
    }


    //分组交换
    /*
    分组交换法： 类似于归并排序，从32位一半位置进行前后置换，例如1011.....1100...会变
    成1100...1011....，其中省略部分与前面四位组成16位。随后，再在前半16位与后半16位再进行折半交换，
    例如：前半16位：11000011 01101110，交换后应该位01101110 11000011，依次类推，直到只剩下1位，
    要取出交换位的数，需要进行mask，例如：前半16位与中前8位与后8位交换，mask为ff00，32位便是ff00ff00表
    示32位数中每16位进行mask，右移8位，交换即可。
    */
    uint32_t reverseBinWithMerge(uint32_t n){
        n = (n >> 16) | (n << 16); //低16位与高16位交换
        n = ((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8); // 每16位中低8位和高8位交换
        n = ((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4); // 每8位中低4位和高4位交换
        n = ((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2); // 每4位中低2位和高2位交换 100 = c 0011=3
        n = ((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1); // 每2位中低1位和高1位交换 1010 = a 0101=5
        return n;
    }

private:

};

int main(){
    Solution s;
    uint32_t input;
    cin>>input;
    uint32_t res = s.reverseBin(input);
    cout<< res <<endl;
    return 0;
}


//ps:测试通过
/*
compile:g++ problem_02_ReverseBinary.cpp -o reverseBin
input:43261596
output:964176192

*/